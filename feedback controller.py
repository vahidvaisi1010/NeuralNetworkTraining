import numpy as np
import math
import scipy
from scipy.integrate import odeint
import matplotlib.pyplot as plt


def model (t,z):
   tx = 0
   ty = 0
   x = z[0]
   y = z[1]
   psi=z[2]
   
   v = 2
   lr=0.23
   delt_x = tx-z[0]
   delt_y = ty-z[1]
   # np.arctan2 **should** work here, but for some reason it doesn't
   # I think this has to do with its behavior for delt_x=delt_y=0; note documentation of np.angle
   # or_angle = np.arctan2(delt_x,delt_y)
   or_angle = np.angle(delt_x + delt_y*1j)

   # Compute a 'wrapped' equivalent of the state angle, psi. See pdf file description.
   wrapped_psi = psi - np.fix(psi/(2*np.pi))*2*np.pi 
   if np.abs(wrapped_psi) >= np.pi:
      wrapped_psi = wrapped_psi - np.sign(wrapped_psi)*2*np.pi

   gainSign = 1
   if (or_angle >=0 and wrapped_psi <= 0 and wrapped_psi <= (or_angle-np.pi)) or (or_angle <=0 and wrapped_psi >= 0 and wrapped_psi >= (or_angle+np.pi)):
      gainSign = -1

   # Compute the control action
   deltaF = gainSign*2*(or_angle - wrapped_psi)

   # Clip the control action *generated by the controller*
   if np.abs(deltaF) > np.pi/4:
      deltaF = np.sign(deltaF)*np.pi/4


   #print([or_angle, wrapped_psi, gainSign, deltaF])

   beta = np.arctan(0.5*np.tan(deltaF))
   dxdt = (v) * np.cos(beta + psi)
   dydt = (v) * np.sin(beta + psi)
   dpsidt = (v/lr) * np.sin(beta)

   return [dxdt, dydt, dpsidt]
   
z = [-2,-4,np.pi-0.1]

#t = np.linspace (0,3,1000)
# z = odeint(model,z,t)
# Switch to more robust ODE solver
sol = scipy.integrate.solve_ivp(model,[0,3],z,max_step=0.01,method='RK45')

tout = sol.t
xout = sol.y[0,:]
yout = sol.y[1,:]

plt.plot(xout,yout)
plt.show()
