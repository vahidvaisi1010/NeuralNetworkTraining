import numpy as np
import math
import scipy
from scipy.integrate import odeint
import matplotlib.pyplot as plt
# import onnx2keras
from onnx2keras import onnx_to_keras
# import keras
import onnx
#from onnx_tf.backend import prepare
def conv():
   onnx_model = onnx.load('finalNets2_net1.onnx')
   k_model = onnx_to_keras(onnx_model,['InputLayer'])
   #k_model.save('myModel')
   main(k_model)

def main(k_model):
   def model (t,z):
      tx = -3
      ty = -3
      x = z[0]
      y = z[1]
      psi=z[2]
      
      rBar = 2
      lr=0.23
      deltaFMax = np.pi/4
      v = 5
      sigma = 0.25
      radiusThresholds = [0,0.25,0.5]
      freeControlThreshold = 0

      delt_x = tx-z[0]
      delt_y = ty-z[1]
      # np.arctan2 **should** work here, but for some reason it doesn't
      # I think this has to do with its behavior for delt_x=delt_y=0; note documentation of np.angle
      # Gamma = np.arctan2(delt_x,delt_y)
      Gamma = np.angle(delt_x + delt_y*1j)

      # Compute a 'wrapped' equivalent of the state angle, psi. See pdf file description.
      wrapped_psi = psi - np.fix(psi/(2*np.pi))*2*np.pi 
      if np.abs(wrapped_psi) >= np.pi:
         wrapped_psi = wrapped_psi - np.sign(wrapped_psi)*2*np.pi

      gainSign = 1
      if (Gamma >=0 and wrapped_psi <= 0 and wrapped_psi <= (Gamma-np.pi)) or (Gamma <=0 and wrapped_psi >= 0 and wrapped_psi >= (Gamma+np.pi)):
         gainSign = -1
         
      # Compute the control action
      deltaF = gainSign*2*(Gamma - wrapped_psi)

      # Clip the control action *generated by the controller*
      if np.abs(deltaF) > np.pi/4:
         deltaF = np.sign(deltaF)*np.pi/4

      #print([Gamma, wrapped_psi, gainSign, deltaF])
      
      beta = np.arctan(0.5*np.tan(deltaF))
         
      xi = (np.angle(x +y*1j)) - wrapped_psi
      wrappedXi = xi - np.fix(xi/(2*np.pi))*2*np.pi 
      if np.abs(wrappedXi) >= np.pi:
         wrappedXi = wrappedXi - np.sign(wrappedXi)*2*np.pi

      input = np.array([[[wrappedXi, beta]]])
      output = k_model.predict(input)
      new_beta = output[0][0][0]
   # new_beta = np.arctan(0.5*np.tan(output))
      dxdt = (v) * np.cos(new_beta + psi)
      dydt = (v) * np.sin(new_beta + psi)
      dpsidt = (v/lr) * np.sin(new_beta)
      
      return [dxdt, dydt, dpsidt]


   z = [3,3,np.pi-0.1]
   #t = np.linspace (0,3,1000)
   # z = odeint(model,z,t)
   # Switch to more robust ODE solver
   sol = scipy.integrate.solve_ivp(model,[0,3],z,max_step=0.01,method='RK45')

   tout = sol.t
   xout = sol.y[0,:]
   yout = sol.y[1,:]

   plt.plot(xout,yout)
   plt.xlim([-4,4])
   plt.ylim([-6,4])
   plt.show()
conv()


